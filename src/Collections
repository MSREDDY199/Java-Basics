ArrayList
`````````
1. A resizable array from java.util package that grows automatically when a new element is added.
2. It implements List interface.
3. Allows duplicate elements and maintains insertion order.
4. Not synchronized, not thread safe.
5. Fast element retrieval, O(n)
6. Slower insertion/deletion as shifting of elements has to happen except at the end.
7. initially the size will be zero, when the first element is added it increases to 10.
8. When the arraylist is full, it creates a new array with size usually 1.5x and copies all the elements to it.

-> Sorting arraylist elements: Collections.sort(list)
-> Add the elements at the end: list.add("Demon")
-> Add an element at a specific position: list.add(1, "Simon")
-> Add one list to another list's end: list.addAll(list2)
-> Remove an element from the end: list.remove()
-> Remove an element from a specified location: list.remove(1);
-> Remove based on condition: list.removeIf(str -> str.contains("Demon")), uses lambda function.
-> Remove all elements from array list, list.clear();

Note -> The size of the arraylist means the total number of elements the list has currently and capacity means the maximum no.of elements it can allow.

Advantages:
1. Dynamic Sizing – Automatically grows/shrinks when elements are added/removed.
2. Random Access – O(1) time to get element by index.
3. Fast Iteration – Easy traversal using loops or iterators.
4. Versatility – Can store any object type (including user-defined classes).
5. Flexibility – Many built-in methods for add, remove, update, etc.
6. Generics Support – Type-safe; avoids runtime type errors.
7. Integration – Part of Java Collections Framework; works well with other collection utilities.

Disadvantages:
1. Resizing Overhead – Growing/shrinking involves copying elements → performance cost.
2. Memory Wastage – May allocate more capacity than needed.
3. Slow Insert/Delete (Middle) – Requires shifting elements.
4. No Primitives Directly – Must use wrapper classes (causes boxing/unboxing overhead).
5. Not Thread-Safe – Requires manual synchronization for multi-threaded use.
   Synchronization can be achieved using synchronization blocks or using Vector or CopyOnWriteArrayList as thread-safe alternatives.
6. Limited Performance for Large Data – LinkedList or HashSet may be better for certain operations.

Linked List
```````````
1. Uses doubly linked list for storing elements.
2. Implements List & Deque interfaces, inherits: AbstractList.
3. Stores elements as nodes (data + reference to previous & next node).
4. Duplicates Allowed – Can store repeated elements.
5. Maintains Insertion Order – Elements remain in the order they were added.
6. Non-Synchronized – Not thread-safe; needs manual synchronization in multi-threaded use.
7. Fast Manipulation – Insertion/deletion is efficient (no shifting like arrays).
8. Multiple Roles – Can act as List, Stack, or Queue.
9. Dynamic Size – Grows/shrinks automatically without resizing arrays.
10. Efficient for Frequent Insert/Delete – Especially in middle of the list.
11. Slower Random Access – Accessing element by index requires traversal (O(n) time).

Hash Set
````````
1. Hash Set internally uses hashing mechanism to store the elements.
2. It stores only unique elements and allows one null value.
3. It is non-synchronised and not thread-safe, to make it thread safe wrap the set in Collections.synchronisedSet method.
4. It doesn't maintain insertion order, to maintain insertion order use Linked Hash Set.
5. It is preferred best for search operations.
6. It's initial capacity is 16 by default and load factor is 0.75
7. Internally HashSet uses HashMap to store elements. Each element in HashSet is stored as key in HashMap, with a dummy value associated with it.

-> Add the elements at the end: set.add("Demon").
-> Add one set to another set: set.addAll(set2).
-> Remove an element from the end: set.remove("Demon").
-> Remove all elements from the set: set.removeAll().
-> Remove based on condition: set.removeIf(str -> str.contains("Demon")), uses lambda function.
-> Remove all elements from array list, set.clear().
-> Add a collection into HashSet, HashSet<String> set=new HashSet(list).

Advantages:
1. O(n) time complexity for adding, removing and checking if an element exists in the list.
2. Quick lookups as it uses hashing technique.

Disadvantages
1. No insertion order.
2. Hashset has higher memory overhead compared to some other data structures.
3. It is not synchronised.

LinkedHashSet
`````````````
1. LinkedHashSet class contains unique elements only like HashSet.
2. LinkedHashSet class provides all optional set operations and permits null elements.
3. LinkedHashSet class is non-synchronized.
4. LinkedHashSet class maintains insertion order.

Tree Set
````````
Tree Set uses binary search tree to store the elements in sorted manner. It takes O(lon(n)) time to add, search and remove the elements.
1. Java tree set uses set interface that uses a tree for storage.
2. Tree set access and retrieval are quite fast.
3. Tree set doesn't allow null values.
4. Tree set class is non-synchronised.
5. Tree set maintains ascending order.
6. It dynamically re-balances the structure during addition or removal of any element to ensure the elements are in ascending order.
7. The sorting order of elements in tree set is natural and it can also be defined by a custom comparator.

Note -> To make the set synchronised, use Collections.synchronizedSet(treeSet)
Note -> Use tree set if required to retrieve ordered data quickly.

HashMap
```````
-> It is not synchronised.
-> It allows to store one null key and multiple null values.
-> It doesn't maintain any insertion order.
-> The initial default capacity of it is 16 and a load factor of 0.75.
-> It offers constant time complexity to add or get elements.
-> To iterate HashMap, entrySet(), keySet() or values() methods are used.
-> The HashMap resizes by itself and rehashes the items to provide optimal performance.
-> Load factor tells us when the hashmap should resize itself with the mentioned capacity.
-> When two distinct keys have same hash, it stores them in the same bucket and preserve the entries using a linked list.
-> A fail-fast iterator (like the one in HashMap) throws ConcurrentModificationException if the collection is structurally modified after the iterator is created,
    except via the iterator’s own remove() method. This prevents inconsistent traversal results.

Internal implementation:
-> Hashing is a process of converting an object into integer value.

-> equals(), it is used to compare the keys of the objects, whether they are equal or not.
-> hashCode(), it returns the memory reference of the object in integer format which is nothing but a bucket number. The bucket number is the address of the element inside the map.
-> Buckets, whenever a hashmap is created, it is created with array of 16 buckets(0-15) by default. Using hashcode() we have to calculate the right bucket number.

Steps:
1.  Whenever a put method is called, hashcode is calculated for the key which is nothing but a bucket number. Note that null keys are stored at 0th bucket.
2.  Once the bucket number is calculated, it will use equals() method to check if the key is same or not, if yes it replaces and if not a linked list is maintained and gets attached to it.
    After Java 8, if the linked list has more than 8 items, list is converted to balanced tree to improve loop-up speed.

Note:
Rehashing is when a HashMap doubles its bucket array and redistributes all entries into the new buckets based on their hash.
Without resizing, too many keys would land in the same buckets → long linked lists/trees → poor performance (O(n)).
Rehashing ensures average O(1) lookup time by preventing too many collisions.

Concurrent Hashmap
``````````````````
ConcurrentHashMap internally divides its data into multiple segments (or buckets). Each segment acts like an independent HashMap and has its own lock.
When a thread needs to perform a write operation (e.g., put, remove) on a specific key, it acquires the lock for the segment corresponding to that key.
This allows other threads to simultaneously operate on different segments without blocking. Read operations generally do not require acquiring locks, further enhancing concurrency.
It doesn't allow null items.

Comparable
``````````
Java Comparable is used to order the objects of user defined class. It contains only one method, compareTo(Object).
It is used to compare the current object with specified object.
-> positive integer, if the current object is greater than the specified object.
-> negative integer, if the current object is less than the specified object.
-> zero, if the current object is equal to the specified object.

eg:
class Student implements Comparable<Student>{
    int rollno;
    String name;
    int age;
    Student(int rollno,String name,int age){
        this.rollno=rollno;
        this.name=name;
        this.age=age;
    }

    public int compareTo(Student st){
        if(age==st.age)
        return 0;
        else if(age>st.age)
        return 1;
        else
        return -1;
    }
}

Comparator
``````````
Java Comparator interface is used to order the objects of a user-defined class.
This interface is found in java.util package and contains 2 methods compare(Object obj1,Object obj2) and equals(Object element).
It's the same as Comparable almost
for examples refer: https://www.tpointtech.com/java-comparator

Comparable vs Comparator
````````````````````````
Comparable
It defines natural ordering within a class.
It is implemented inside the class being sorted.
It uses the compareTo() method.
It allows sorting by one one.
Comparator
It defines custom sorting logic
It is implemented in a separate class or using lambda expressions.
It uses the compare() method.
It allows sorting by multiple criteria.










