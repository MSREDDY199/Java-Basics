What is Java Memory model?
``````````````````````````
-> JMM defines how threads interact with memory in java.
-> It is needed because modern compilers or CPUs may reorder the instructions and use caches, and one thread may see stale data written by another thread which can cause
data inconsistency. JMM gives rules to write thread safe code.
-> It defines order of operations between the threads. If A happens-before B, then B will see the effects of A.

Memory Leaks
````````````
To reclaim the space GC tries to remove the unused objects from the memory and sometimes it cannot remove the objects that are no longer required by application as it
still has some active references. And this causes memory full and JVM throws OutOfMemoryError Exception.

Java Memory Structure overview
``````````````````````````````
At runtime, JVM creates certain runtime data areas:
1. Heap memory
2. Stack memory
3. Method Area (Implemented as Metaspace in Java 8+)
4. Program Counter (PC) Register
5. Native Method Stack

Each area plays a unique role in executing Java programs and managing resources.

1. HEAP MEMORY
``````````````
All class instances, arrays, and objects created during program execution are stored in Heap.
Unlike stack memory, Heap is shared memory space and accessed by all the threads in JVM.
It is automatically managed by Garbage collector, which reclaims the memory occupied by objects not in use.

-> JVM divides the Heap memory in two parts:
Young Generation and Old Generation.

-> The Young Generation:
    The Young generation is the space where newly created objects are placed. It is optimized for fast allocation and frequent garbage collection.
    Because the majority of the objects are short lived(method local variables, temporary buffers), Minor Garbage Collectors are used which are fast and efficient.

    Young generation internally divided into three spaces:
     -> Eden: Initially all the objects are placed here, when Eden is filled up Minor GC is triggered.
     -> Survivor Spaces (S0 and S1) : After Each Minor GC in Eden space, object are moved between S0 and S1.

    As object survive for longer ages and if it crossed threshold (controlled by the JVM flag -XX:MaxTenuringThreshold), it is promoted to Old Generation Space. Promotion is also forced
    when Survivor space is filled up.

    Minor GCs are stop-the-world events, meaning all application threads are paused while this GC happens, and these pauses are minimal as the live data volume is small.

-> The Old Generation:
    It is designed to hold long lived objects, those who have survived multiple Minor GCs. In Old generation objects that used for extended period of time are stored, examples like:
    - Persistent application-level caches
    - Large object graphs such as sessions or user data
    - Static or shared data structures that are retained across requests

    Since objects in this space are used for longer ages, very less frequently GC happens and this GC is called as Major GC. And when both Generations are collected it is called as Major GC.

    Collections in Old generation is very expensive and it involves:
    - A full stop-the-world pause
    - Tracing all reachable objects starting from the GC roots
    - Compacting memory to eliminate fragmentation

    Single threaded collection like Serial GC will take longer time where as parallel or concurrent collectors like Parallel GC, CMS or G1 reduce the time by using multiple threads.

    If the old generation is full and if the GC is unable to reclaim the space, JVM will throw a java.lang.OutOfMemoryError: Java heap space.
    example to set configurations of Heap memory:
        command: -Xms512m -Xmx2g -Xmn512m -XX:NewRatio=3
        This configuration sets an initial heap size of 512 MB, a maximum heap size of 2 GB, allocates 512 MB to the Young Generation,
        and ensures the Old Generation is roughly three times larger than the Young Generation.

2. STACK MEMORY
```````````````
Stack memory plays crucial role in method execution. Unlike Heap memory which stores objects for longer duration and shared across threads,
Stack memory exists independently for each thread.
When a thread is created, JVM allocates a new Java stack for that thread and it contains series of stack frames, each representing single method invocation.
As methods are called and return, frames are pushed to and popped from the top of the stack in a strict last-in, first-out (LIFO) order.

Everytime a method invoked, JVM allocates a new Frame on the thread's stack. This frame hold the necessary data of that invocation. The frame remains on the stack until the method
either completes(returns) or exists abruptly and then frame is removed from the stack automatically; no GC required for stack memory.

Stack frames are lightweight and quick to allocate, as they are thread-local and do not require synchronization, operations on stacks are extremely fast.

Inside a Stack frame, the local variable array stores all the variable like primitive values(int, double, float), object references and Method parameters.
Only references to objects are stored in stack, the actual object is stored in heap memory.

Stack Size and Overflow:
    Each thread stack is limited, and can be configured using -Xss JVM option. example:
    command: -Xss1m, maximum stack size set to 1 mega bytes.
    If stack exceeds the limit, StackOverFlow error gets thrown. And this happens during deep recursion with no base case, Method chaining or Improper termination condition in recursion.

3. Method Area Space
````````````````````

4. Program Counter (PC) register
````````````````````````````````

5. Native Method Stack
``````````````````````

Garbage Collection in  Java
```````````````````````````
-> Garbage Collection is Java's automatic memory management system.
-> JVM automatically allocates memory for new objects in the heap, and as long as an object remains reachable through local variables,
   static references, or other live objects, it stays alive.
-> Once the object becomes unreachable, it becomes eligible for garbage collection.

It Frees up memory occupied by unreachable objects.
It Prevents memory leaks and heap exhaustion.
It Ensures long-running applications continue to operate without manual intervention.

Garbage collection algorithms in Java
`````````````````````````````````````
->  Serial garbage collection:
    It uses single thread to perform garbage collection, pausing the application during each garbage collection. It's ideal for small application where pause times are
    acceptable due to it's simplicity and low overhead.
    It doesn't scale well in multi-core CPUs or large memory heaps due to it's long pause times.
    Enable command: -XX:+UseSerialGC

->  Parallel GC:
    It uses multiple threads to perform garbage collection, which improves overall throughput by reducing time spent in GC.
    It is designed for maximum CPU efficiency and throughput are more important than pause times.
    However, since it still pauses the application during collection, it may not be ideal for latency-sensitive applications.
    Enable with: -XX:+UseParallelGC

->  G1 GC (Garbage First):
    It is region based, low-pause collector designed to balance between throughput and pause time.
    It incrementally collects small regions of the heap to avoid full GC pauses and provides tunable pause-time goals.
    G1 became the default collector starting in Java 9 and is well-suited for server applications, microservices, and systems with moderate to large heaps.
    It provides a good balance between performance and manageability, although tuning can be more complex than older collectors.
    Enable with: -XX:+UseG1GC

->  ZGC (Z Garbage Collector):
    It is low latency GC introduce in Java 11, designed to keep pause times consistently below 10 milliseconds, even with heap sizes in the multi-terabyte range.
    It achieves this by performing all heavy GC phases concurrently with the application.
    Enable with: -XX:+UseZGC (stable since Java 15).

->  Shenandoah:
    Shenandoah is another modern low-pause collector, developed by Red Hat, which performs concurrent compaction, a feature ZGC lacks.
    This makes it suitable for systems that require both low pause times and heap defragmentation.
    Shenandoah is best suited for low-latency services such as databases, real-time systems, or interactive applications with strict response time requirements.
    It can introduce slightly higher CPU overhead due to more frequent write barriers and increased GC activity.
    Enable with: -XX:+UseShenandoahGC (production-ready in Java 15+)

    Note: Memory compaction is a technique used in memory management to reduce fragmentation by reorganizing memory and combining scattered free spaces into a single, contiguous block.

->  Garbage Collection Phases: Mark, Sweep, and Compact:
    Mark: GC marks the reachable objects from the root.
    Sweep: Once marking is done, all the unreachable objects are cleared.
    Compact(optional): reduces fragmentation.

->  Minor GC vs. Major GC vs. Full GC:
    - Minor GC: A Minor GC collects the Young Generation only. It is frequent, fast, and typically involves copying live objects to survivor spaces or promoting them to the Old Generation.
      Minor GCs are stop-the-world events but generally have short pause times.
    - Major GC: A Major GC collects the Old Generation. It is less frequent and more expensive in terms of time and CPU usage.
      These events are also stop-the-world and can lead to noticeable pauses if not managed well.
    - Full GC: A Full GC collects the entire heap, including both Young and Old Generations. Depending on the collector and JVM version, it may also include Metaspace cleanup.
      Full GCs are the most disruptive and should be avoided in latency-sensitive applications.

->  Tuning Garbage Collection:
    The performance and behavior of the JVM’s garbage collector can be tuned with a range of JVM options, allowing developers to optimize for throughput, pause time, or
    memory footprint depending on their application’s needs.

    # Heap size
    -Xms512m -Xmx2g

    # Young Generation size
    -Xmn512m

    # GC collector selection
    -XX:+UseG1GC
    -XX:+UseParallelGC
    -XX:+UseZGC
    -XX:+UseShenandoahGC

    # GC logging
    -Xlog:gc*:file=gc.log:time,uptime,level,tags

    Monitoring tools like JFR, VisualVM, and jstat can help observe GC behavior and identify tuning opportunities.

-> Ideal GCs:
   Serial GC: Small apps, single-threaded or embedded systems and supports compaction. High pauses.
   Parallel GC: Batch jobs, compute-heavy services, large heaps with loose latency requirements and supports compaction. Moderate-high pauses.
   G1 GC: General-purpose apps, moderate-latency SLAs. Low-Moderate pauses.
   ZGC: Real-time, large-heap, low-latency systems. Very low pauses.
   Shenandoah: Interactive, real-time systems needing low pause and compaction. Very low pauses.

